function [S,y,e]=LeastMeanSquare(S,x,d)
%最小均方自适应滤波算法,以输入的统计特性自动调整抽头权重,使其接近期望.
% 调用方式:
%   S = LeastMeanSquare; %创建滤波器迭代对象
%   S.M=16;S.p=0.1;%设置参数
%   [S,y,e] = LeastMeanSquare(S,x,d); %更新观测值x,期望值d; 返回迭代对象S,适应结果y,误差e.
%
%   S.M是自适应滤波器的阶数.
%   S.p是收敛因子(步长)
%      - 标量,要求大于0,小于观测相关矩阵最大特征值的倒数.
%      - 向量[a,b],则使用NLMS,0 < a < 1, b 为避免除0的较小数.
%        通常a越大,收敛速度越快,但收敛越不稳定.
%   S.W是当前最佳权值矩阵,
% 回声消除时:
%   x   远端参考信号
%   d   近端信号(回声+本地语音+环境噪声)
%   y   估计的回声
%   e   估计的本地语音信号
%
if nargin == 0 %创建对象
    if nargout > 1; error('Redundant output parameters'); end
    S.p = 0.01;
    S.M = 16;
    S.W = nan;
    S.a = nan;
    return;
elseif nargin ~=3
    error('need input/output vector');
end
if isnan(S.W) %初始化
    if isnan(S.M) | isnan(S.p); error('must set M and p'); end
    S.W = zeros(S.M,1);
    if length(S.p) > 1 %NLMS
        S.a=S.p(1)/2;
        S.b=eye(S.M)*S.p(2);
    end
    S.M = repmat(x,1,S.M);
end
X=[S.M(:,2:end),x];%M个抽头
y=X*S.W;%滤波值
e=d-y;
if isnan(S.a)
    p=S.p;
else
    p=S.a*inv(X.'*X+S.b);%NLMS
end
S.W=S.W + 2*p*X.'*e;
S.M=X;
return;
%===============================================================================
% 模型:
%   设x,d为随机变量,都是相同维数(rxn)的列向量
%       x[1],x[2],...x[n] 为带噪声的输入信号
%       d[1],d[2],...d[n] 为期望得到的输出信号
%
%   第k(k>M)次迭代时,选取M(自适应滤波器的阶数)个采样:
%   M个输入:    X    = X[k]=[x[k], x[k-2],...x[k-M+1] rxM矩阵
%   上次权向量: W    = W[k-1]=[w[1], w[2],...w[M]]'   Mx1矩阵
%   期望:       d    = d[k]
%   相关期望:   Q    = E(X'X), X'X 为相关矩阵,M维方阵
%
%   求最佳矩阵 W, 使得 X*W 与 d 最接近 
%--------------------------------------------------------------------
% 推导:
%   滤波输出:         y    = XW
%   误差:             D    = d[k] - y = d - XW
%   误差平方(标量):   D^2  = (XW-d)'*(XW-d) = (W'X'-d')(XW-d)
%                          = W'X'XW-W'X'd-d'XW+d'd, 因标量,故 W'X'd == (W'X'd)' = d'XW
%                          = W'X'XW-2d'XW+d'd
%
%   均方差(求期望,标量): P = E(D^2) = E(d'd) - 2E(d'X)W + W'E(X'X)W,
%   令 R' = E(d'X),  Q  = E(X'X), R为Mx1矩阵,Q为MxM矩阵,则
%                       P = E(d'd) - 2R'W + W'QW 
%   表明 P 是 W 的二次函数, 存在极小值,对W求导数,且为0时达到最优值
%   由矩阵求导公式得
%   均方差梯度:    U = diff(P, W) = -2R + QW + Q'W, 因Q为对称阵
%                                 = -2R + 2QW
%   导数为0时,达极值,令 U = 0,则
%       最优W = inv(Q)R = Q\R,
%
%   代入均方差得
%           P = E(d'd) - 2R'W + W'R, 因标量,故 W'R == R‘W
%             = E(d'd) - R'W
%--------------------------------------------------------------------
% 算法:
%   设迭代  W[k] = W[k-1] - p*U
%   p 是控制收敛速度与稳定性的常量,称收敛因子
%
%   计算均方差梯度 U 的精确值很难,一种有效的近似计算如下
%   直接将 D^2 作为 E(D^2) 的值, 即
%         P = E(D^2) ~ D^2 = (XW-d)'*(XW-d) = W'X'XW-2d'XW+d'd
%   由矩阵求导公式得
%         U = diff(P,W) = 2X'XW-2X'd + 0 = -2X'(d-XW) = -2X'*D
%   则迭代公式为
%       W[k] = W - p*U = W + 2pX'D
%            = W[k-1] + 2p*X'[k]*D[k]
%   两侧求数学期望
%    E(W[k]) = E(W) + 2p*E(X'D) 
%            = E(W) + 2p*E(X'd-X'XW)
%            = (1-2p*E(X'X))*E(W)+2p*E(X'd),
%   令 R' = E(d'X), Q=E(X'X), R为Mx1矩阵,Q为MxM矩阵,相关矩阵
%     E(W[k]) = (1-2pQ)*E(W[k-1])+2pR
%   由迭代关系,逐一计算可得
%    E(W[k]) = (1-2pQ)*E(W[k-1])   + 2pR
%            = (1-2pQ)^2*E(W[k-2]) + 2p(1+(1-2pQ))R
%            = ......
%            = (1-2pQ)^k * E(W[0]) + 2p*sum{i=0,k-1,(1-2pQ)^i} * R
%
%   由Q为实对称矩阵，可正交阵对角化,对角阵上的元素即矩阵本身特征值.
%      Q = TFT', 其中,F为对角方阵,T为正交阵
%   因此
%      (1-2pQ)^k = （TT'-2pTFT')^k =T*(1-2pF)^k * T'
%   sum{i=0,k-1,(1-2pQ)^i}=T*sum{i=0,inf,(1-2pF)^i}*T'
%   假设(1-2pF)的对角元素值均< 1,这可以通过适当选择p来实现.
%   当 k->inf 时,
%      (1-2pQ)^k -> 0,所以与初始W[0]无关
%          根据等比数列和极限
%                  S=sum{i=0,n, a^i}; S-a*S=1 - a*a^n;
%             因此 S= 1-a*a^n/(1-a),当n->inf时, S=1/(1-a)
%      sum{i=0,inf,(1-2pF)^i} -> inv(2pF)
%   因此
%      E(W[k]) -> 2p*T*inv(2pF)*T'*R
%              =  T*inv(F)*T'* R
%              =  inv(Q)R = Q\R = 最优W
% 由此可见,当迭代次数无限增加时,权系数矩阵W收敛到最优值的条件是
%              0 < 1-2pF < 1
%               0< p <1/F
% 即 p 必须小于最大特征值的倒数
%       T(1-2pF)T' = (1-2pQ) < 1
% p 称收敛因子,决定了收敛速度
%--------------------------------------------------------------------
% NLMS 归一化最小均方自适应滤波算法
%   收敛因子p 自动取
%       p = a/2*inv(X'X), M方阵
%   则
%     0 < 1-2pQ = 1-a*E(X'X)*inv(X'X)  < 1,  求数学期望
%     0 < a < 1,  通常a越大,收敛速度越快.
%
%   迭代公式为
%       W[k] = W + 2pX'D = W + aX'D/(b+X'X)
%   其中
%     p = (a/2)./(b+X'X)
%     a 是修正的步长常量，0 < a < 1,
%     b 为一个较小数，避免除0, 一般取最小值0.000001或eps
